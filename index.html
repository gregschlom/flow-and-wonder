<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="js/three.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="HexCoord.js"></script>
    <script>

        // Fix the js modulo bug
        // See: http://javascript.about.com/od/problemsolving/a/modulobug.htm
        Number.prototype.mod = function (n)
        {
            return ((this % n) + n) % n;
        }

        // trunc is defined in ECMAScript 6 - fix for older browsers
        Math.trunc = function (a)
        {
            return (a >= 0) ? Math.floor(a) : Math.ceil(a);
        }


        // Set up FPS counter
        var stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        document.body.appendChild(stats.domElement);

        // Set up the renderer
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(new THREE.Color(0x090912, 1));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ====== Scene description ======= //

        var scene = new THREE.Scene();

        // Camera
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);
        scene.add(camera);

        var controls = new THREE.OrbitControls(camera, renderer.domElement);

        // LEDs (particles)
        var numLEDs = 1027;
        var size = .09
        var geometry = new THREE.Geometry();
        geometry.hex = new Array();

        for (var i = 0; i < numLEDs; i++) {
            var h = HexCoord.fromSpiral(i);
            var pos = h.position();
            pos.normalize().multiplyScalar(size * h.polarRadius());

            geometry.vertices.push(new THREE.Vector3(pos.x, pos.y, 0));
            geometry.colors.push(new THREE.Color());
            geometry.hex.push(h);
        }

        var material = new THREE.PointCloudMaterial({ size: .04, vertexColors: THREE.VertexColors });
        var leds = new THREE.PointCloud(geometry, material);
        leds.position.y = -.5;
        scene.add(leds);

        // ====== Animation loop ======= //

        var frame = 0;
        var render = function () {
            stats.begin();
            requestAnimationFrame(render);

            for (var i = 0; i < numLEDs; i++) leds.geometry.colors[i].setRGB(1, 1, 1);

            var time = frame * .005;
            for (var i = 0; i < numLEDs; i++) {
                var hex = leds.geometry.hex[i];
                var pos = hex.position().multiplyScalar(size);
                var color1, color2, color;

                color1 = (Math.sin(pos.x * Math.sin(time * 3) + pos.y * Math.cos(time * 3) * 0.02 + time * 3) + 1) / 2;

                var radius = Math.ceil((Math.sqrt(9 + 12 * 1024) - 3) / 6);
                var center = new THREE.Vector2(
                    size * radius * Math.sin(time * 3),
                    size * radius * Math.cos(time * 3));
	
                var length = center.distanceTo(pos);
                var color2 = (Math.cos(length * 0.03) + 1) / 2;
	
                var color = (color1 + color2) / 2;

                leds.geometry.colors[i].setRGB(
                    (Math.cos(Math.PI * color / 0.5 + time * 3) + 1) / 2,
                    (Math.sin(Math.PI * color / 0.5 + time * 3) + 1) / 2,
                    (Math.sin(+time * 3) + 1) / 2 );
            }

            leds.geometry.colorsNeedUpdate = true;
            frame++;

            controls.update();
            renderer.render(scene, camera);
            stats.end();
        };

        render();
    </script>
</body>
</html>