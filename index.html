<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="threejs/three.js"></script>
    <script src="threejs/stats.min.js"></script>
    <script src="threejs/OrbitControls.js"></script>
    <script src="utils.js"></script>
    <script src="HexCoord.js"></script>
    <script src="MousePos.js"></script>
    <script src="Fluid.js"></script>
    <script src="Scene.js"></script>

    <script>


        var scene = new Scene();
        var mousePos = new MousePos(scene.renderer.domElement, scene.camera);
        var fluid = new NavierStokes({ resolution: 32 });

        var tracers = scene.tracers.geometry;
        var fluidParticles = new Array();
//        var size = 32;
//        for (var y = 0; y < size; y++) {
//            for (var x = 0; x < size; x++) {
//                var p = new THREE.Vector2(2*x / size - 1 + 1/size, 2*y / size - 1 + 1/size);
//                var c = new THREE.Color();
//                c.setHSL(p.length(), 1, .5);
//                fluidParticles.push({pos: p, color: c});
//                tracers.vertices.push(new THREE.Vector3(p.x, 0, p.y));
//                tracers.colors.push(c);
//            }
//        }

        var c = new THREE.Color();
        c.setHSL(0, 1,.5);
        fluidParticles.push({pos: new THREE.Vector3(), color: c});
        tracers.vertices.push(new THREE.Vector3());
        tracers.colors.push(c);

        for (var i = 1; i <= 18; i++) {
            for (var j = 0; j < i * 6; j++) {
                var c = new THREE.Color();
                c.setHSL(i / 18, 1,.5);
                fluidParticles.push({pos: new THREE.Vector3(), color: c});
                tracers.vertices.push(new THREE.Vector3());
                tracers.colors.push(c);
            }
        }

        tracers.colorsNeedUpdate = true;
        tracers.verticesNeedUpdate = true;

        var feature_size = 1 / 18;     //   1 / radius
        var cell_size = feature_size / Math.sqrt(2);
        var grid_size = Math.ceil(2 / cell_size);                // coords go from from -1 to 1 => 2
        var grid = new Array(grid_size*grid_size);


        scene.update = function (frame) {

            interactWithFluid(fluid, mousePos);
            updateFluidParticles(fluid, fluidParticles);
            putParticlesInGrid(fluidParticles, grid, grid_size);
        };


        // r: radius normalized in [0, 1]
        // a: angle in radians [0, 2π]
        scene.computeColorPolar = function(r, a, frame)
        {
            // trippy mandala
            var time = frame / 60;
            var c = new THREE.Color();
            var lol = (Math.abs(Math.abs(Math.sin(a * 3 + .2*time * Math.TAU)) - r) + time) % 1;
            c.setHSL(lol, 1, .5);
            return c;
        }

        scene.computeColor = function(x, y, frame)
        {
            var c = new THREE.Color(0);

            var pos = new THREE.Vector2(x, y);
            var gx = Math.floor((x + 1) / 2 * grid_size);
            var gy = Math.floor((y + 1) / 2 * grid_size);

            var closest = feature_size;
            for (var dy = -1; dy <=1; dy++) {
                for (var dx = -1; dx <=1; dx++) {
                    var px = gx + dx, py = gy + dy;
                    if (px < 0 || py < 0 || px >= grid_size || py >= grid_size) continue;
                    var index = py * grid_size + px;
                    for (var i = 0; i < grid[index].length; i++) {
                        var particle = grid[index][i];
                        var dist = pos.distanceTo(particle.pos);
                        if (dist < closest ) {
                            closest = dist;
                            var coverage = (feature_size - dist) / feature_size;
                            c.copy(particle.color).multiplyScalar(coverage);
                            //c = particle.color;
                        }
                    }
                }
            }

            return c;
        }

        scene.start();

        // Update velocities in the fluid according to the mouse movements
        function interactWithFluid(fluid, mousePos)
        {
            var newU = new Array();
            var newV = new Array();

            if (mousePos.last && mousePos.cur) {

                var px = Math.floor((mousePos.cur.x + 1) / 2 * fluid.settings.resolution) + 1;
                var py = Math.floor((mousePos.cur.y + 1) / 2 * fluid.settings.resolution) + 1;

                if (px < 1 || px >= fluid.settings.resolution || py < 1 || py >= fluid.settings.resolution) return;

                var index = fluid.IX[px][py];

                newU[index] = (mousePos.cur.x - mousePos.last.x) * 100;
                newV[index] = (mousePos.cur.y - mousePos.last.y) * 100;
            }

            fluid.update(newU, newV);
        }

        function updateFluidParticles(fluid, particles) {
            for (var i = 0; i < particles.length; i++) {

                // Update the position based on the fluid
                var pos = particles[i].pos;
                var px = Math.floor((pos.x + 1) / 2 * fluid.settings.resolution) + 1;
                var py = Math.floor((pos.y + 1) / 2 * fluid.settings.resolution) + 1;

                var index = fluid.IX[px][py];
                var velocity = new THREE.Vector2(fluid.U[index], fluid.V[index]);

                // enforce 60degrees angles
//                var angle = Math.atan2(velocity.y, velocity.x);
//                var speed = velocity.length();
//                angle = Math.round((angle / Math.TAU) * 6) / 6 * Math.TAU;
//                velocity.set(speed * Math.cos(angle), speed * Math.sin(angle));

                pos.add(velocity);

                // bounce off the walls
                if (pos.x < -1) pos.x = -1 - pos.x % 1;
                if (pos.x > 1) pos.x = 1 - pos.x % 1;
                if (pos.y < -1) pos.y = -1 - pos.y % 1;
                if (pos.y > 1) pos.y = 1 - pos.y % 1;

                tracers.vertices[i].set(pos.x, 0, pos.y);

//                // Return to original position
                var minSpeed = .01;
                if (fluid.U[index] < minSpeed && fluid.V[index] < minSpeed) {
                    var origPos = scene.leds.geometry.vertices[i];
                    origPos = new THREE.Vector2(origPos.x, origPos.z);
                    pos.lerp(origPos, 1 / 60);
                }
            }
            tracers.verticesNeedUpdate = true;
        }

        // feature_size: the size of each "pixel"
        function putParticlesInGrid(particles, grid, grid_size)
        {
            // clear grid
            for (var i = 0; i < grid.length; i++) {
                grid[i] = [];
            }

            for (var i = 0; i < particles.length; i++) {
                var pos = particles[i].pos;
                //if (pos.x > 1 || pos.x < -1 || pos.y < -1 || pos.y > 1) console.log(pos);
                var px = Math.floor((pos.x + 1) / 2 * grid_size);
                var py = Math.floor((pos.y + 1) / 2 * grid_size);

                var index = py * grid_size + px;
                grid[index].push(particles[i]);
            }
        }

        function assert(condition, msg)
        {
            if (!condition) throw new Error(msg);
        }

        document.onkeypress = function(event) {
            if (event.key == "t") scene.tracers.visible = !scene.tracers.visible;
            if (event.key == "r") scene.leds.visible = !scene.leds.visible;
        }


    </script>
</body>
</html>