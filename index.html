<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="js/three.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="HexCoord.js"></script>
    <script>

        // Fix the js modulo bug
        // See: http://javascript.about.com/od/problemsolving/a/modulobug.htm
        Number.prototype.mod = function (n)
        {
            return ((this % n) + n) % n;
        }

        // trunc is defined in ECMAScript 6 - fix for older browsers
        Math.trunc = function (a)
        {
            return (a >= 0) ? Math.floor(a) : Math.ceil(a);
        }

        Number.prototype.clamp = function (min, max)
        {
            return Math.min(Math.max(this, min), max);
        };

        var TAU = Math.PI * 2;


        // Set up FPS counter
        var stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        document.body.appendChild(stats.domElement);

        // Set up the renderer
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(new THREE.Color(0x090912, 1));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ====== Scene description ======= //

        var scene = new THREE.Scene();

        // Camera
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 3, 0);
        scene.add(camera);

        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.mouseButtons = { ORBIT: THREE.MOUSE.RIGHT, ZOOM: THREE.MOUSE.MIDDLE /*, PAN: THREE.MOUSE.LEFT */ };


        var sphere = new THREE.Mesh(
            new THREE.SphereGeometry(.01, 32, 32), 
            new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        scene.add(sphere);

        // LEDs (particles)
        var radius = 18;
        var numLEDs = HexCoord.cellCountInRadius(radius);
        var geometry = new THREE.Geometry();
        geometry.hex = new Array();

        for (var i = 0; i < numLEDs; i++) {
            var h = HexCoord.fromSpiral(i);
            var pos = h.position();
            pos.normalize().multiplyScalar(h.polarRadius() / radius);

            // jitter
            var factor = .02;
            var rnd = new THREE.Vector2(Math.random() * factor - factor / 2, Math.random() * factor - factor / 2);
            pos.add(rnd);

            geometry.vertices.push(new THREE.Vector3(pos.x, 0, pos.y));
            geometry.colors.push(new THREE.Color());
            geometry.hex.push(h);
        }

        var material = new THREE.PointCloudMaterial({ size: .02, vertexColors: THREE.VertexColors });
        var leds = new THREE.PointCloud(geometry, material);
        scene.add(leds);

        // ====== Animation loop ======= //

        var frame = 0;
        var state = {
            point: new THREE.Vector2(.5, -.5),
            pos: []
        };

        var render = function () {
            stats.begin();
            requestAnimationFrame(render);

            var time = frame / 60;

            for (var i = 0; i < numLEDs; i++) {
                var pos = leds.geometry.vertices[i];
                var hex = leds.geometry.hex[i];
                //leds.geometry.colors[i] = computeColor(pos.x, pos.z, frame, state);
                updateState(frame, state);
                leds.geometry.colors[i] = computeColor2(hex.polarRadius(), hex.polarIndex(), frame, state);
            }

            leds.geometry.colorsNeedUpdate = true;
            frame++;

            controls.update();
            renderer.render(scene, camera);
            stats.end();
        };

        render();

        // return the color at a given x,y coordinate
        // x and y are normalized in [-1, 1].
        function computeColor(x, y, frame, state)
        {
            var time = frame / 60;
            x = x * .5 + .5;
            y = y * .5 + .5;

            var color = new THREE.Color();
            color.setHSL(60 / 360, .5, .5);
            if (x > .5) color.offsetHSL(.5, 0, 0);
            return color;


            // BEACH BALL
            //var pos = new THREE.Vector2(x, y);

            //var lol = state.point.clone().sub(pos);
            //var angle = Math.atan2(lol.y, lol.x);
            //var dist = lol.length();

            //// Rotate the angle, 1 revolution per second
            //var angle2 = (angle + time * TAU) % TAU;

            //var effectRadius = .4; // + .05 * Math.cos(2*(angle + .4*time * TAU) % TAU);
            //var intensity = Math.max((effectRadius - dist), 0) / effectRadius;

            ////intensity *= Math.abs(Math.sin(8*(-dist + time)));

            //var color = new THREE.Color();
            //color.setHSL(angle2 / TAU, 1, intensity * .5);
            //return color;
        }

        function updateState(frame, state) 
        {
            var time = frame / 60;
            var angle = TAU * time / (1*60); // base angle, 1 RPM
            for (var i = 1; i <= radius; i++) {
                state.pos[i] = (angle * (radius + 1 - i)) % TAU;
            }
        }

        function computeColor2(r, a, frame, state)
        {
            var time = frame / 60;
            var maxA = 6 * radius - 1;
            var bs = 2;

            var color = new THREE.Color(0);

            var thisAngle = TAU * a / (6 * r);

            for (var i = -1; i <= 1; i++) {
                var dist = Math.abs(thisAngle - state.pos[r + i]) * r;
                var lol = Math.max(0, bs - dist) / bs;
                if (lol > 0) color.setHSL([r + i] / radius, 1, lol / 2);
            }
            

            return color;
        }

        function onMouseDown(event)
        {
            if (event.button === THREE.MOUSE.LEFT) {

                var pos = getMousePos(event);
                state.point.copy(pos);

                document.addEventListener('mousemove', onMouseMove, false);
                document.addEventListener('mouseup', onMouseUp, false);
            }
        }

        function onMouseMove(event)
        {
            event.preventDefault();
            var pos = getMousePos(event);
            state.point.copy(pos);
        }

        function onMouseUp(event)
        {
            document.removeEventListener('mousemove', onMouseMove, false);
            document.removeEventListener('mouseup', onMouseUp, false);
        }

        function getMousePos(event)
        {
            var mouse3D = new THREE.Vector3(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1,
                .5);

            mouse3D.unproject(camera);

            // project mouse3D on the y=0 plane
            mouse3D.sub(camera.position).multiplyScalar(-camera.position.y / mouse3D.y).add(camera.position);

            return new THREE.Vector2(mouse3D.x, mouse3D.z);
        }

        renderer.domElement.addEventListener('mousedown', onMouseDown, false);

    </script>
</body>
</html>