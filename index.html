<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="threejs/three.js"></script>
    <script src="threejs/stats.min.js"></script>
    <script src="threejs/OrbitControls.js"></script>    
    <script src="dat.gui.min.js"></script>
    <script src="utils.js"></script>
    <script src="colors.js"></script>
    <script src="HexCoord.js"></script>
    <script src="MousePos.js"></script>
    <script src="fluid2.js"></script>
    <script src="Scene.js"></script>

    <script>

        var FWGUI = function() {
            this.centerDisplacementSpeed = 0.09;            
            this.fluidSimulationOn = true;
            this.bandSize = 0.25;
            this.whiteHaloRadius = 0.5;
            this.colorFunction = 2;  
            this.colorPalette = 3;          
        };  

        // Parameters GUI
        var fwgui = new FWGUI();        
        var gui = new dat.GUI();
        gui.add(fwgui, 'centerDisplacementSpeed',0,1);        
        gui.add(fwgui, 'bandSize',0,1);
        gui.add(fwgui, 'whiteHaloRadius',0,1);
        gui.add(fwgui, 'fluidSimulationOn');        
        gui.add(fwgui, 'colorFunction', { Eiffel: 0, 
                                         TravelingRing: 1, 
                                         Ambient: 2,
                                         Mandala: 3,
                                         ColorRing: 4,
                                         Plasma: 5,
                                         TravelingBand: 6 });

        gui.add(fwgui, 'colorPalette', { Palette1: 0,
                                         Palette2: 1,
                                         BW: 2,
                                         Tycho: 3 });

        var scene = new Scene();
        var mousePos = new MousePos(scene.renderer.domElement, scene.camera, scene);        
        var userIsInteracting = false;
        var interactionCenter = new THREE.Vector2(0,0);                

        scene.update = function (frame) {
            if (fwgui.fluidSimulationOn) {
                simulate(mousePos);
            }

            // Offset center if user is interacting
            var destination;
            if (mousePos.last && mousePos.cur) {                
                destination = new THREE.Vector2(mousePos.cur.x, mousePos.cur.y);
                userIsInteracting = true;  
            }
            // Going back to center if user is not interaction
            else {
                destination = new THREE.Vector2(0, 0);
                userIsInteracting = false;                
            }

            var diff = new THREE.Vector2(destination.x - interactionCenter.x, destination.y - interactionCenter.y);
            interactionCenter.add(diff.multiplyScalar(fwgui.centerDisplacementSpeed));
        };


        // x,y: coords from -1 to 1
        scene.computeColor = function(x, y, frame, state)
        {
            var time = frame / 60;            

            // Get the fluid parameters
            // WIDTH and HEIGHT: number of cells in the fluid simulation.
            // Our coords are in [-1, 1] and we want to convert to [0, 100]
            var gx = Math.floor((x + 1) / 2 * WIDTH);
            var gy = Math.floor((y + 1) / 2 * HEIGHT);
            var p = p0(gx, gy);   // pressure
            var u = u0x(gx, gy);  // x-axis velocity
            var v = u0y(gx, gy);  // y-axis velocity

            state.vpos.x += u;
            state.vpos.y += v;

            // bounce off the walls
            if (state.vpos.x < -1) state.vpos.x = -1 - state.vpos.x % 1;
            if (state.vpos.x > 1) state.vpos.x = 1 - state.vpos.x % 1;
            if (state.vpos.y < -1) state.vpos.y = -1 - state.vpos.y % 1;
            if (state.vpos.y > 1) state.vpos.y = 1 - state.vpos.y % 1;

            state.vpos.lerp(new THREE.Vector2(x, y), 1/5);
            
            var c;
            if (fwgui.colorFunction == 0) {
                c = eiffel(state.vpos.x, state.vpos.y, time);            
            }
            else if (fwgui.colorFunction == 1) {
                c = travelingColorRing(state.vpos.x, state.vpos.y, time);            
            }
            else if (fwgui.colorFunction == 2) {
                c = ambient(state.vpos.x, state.vpos.y, time);            
            }
            else if (fwgui.colorFunction == 3) {
                c = mandala(state.vpos.x, state.vpos.y, time);            
            }
            else if (fwgui.colorFunction == 4) {
                c = colorRing(state.vpos.x, state.vpos.y, time);            
            }
            else if (fwgui.colorFunction == 5) {
                c = plasma(state.vpos.x, state.vpos.y, time);            
            }
            else if (fwgui.colorFunction == 6) {
                c = travelingColorBand(state.vpos.x, state.vpos.y, time);            
            }

            if (p < .5) p *= 2;
            c.offsetHSL(0,0, -p);

            return c;
        }

        scene.start();

        function eiffel(x, y, time)
        {   
            if (getRandomInt(1,2) % 2 == 0) {
                return new THREE.Color("rgb(255,255,255)");
            }

            else {
                return new THREE.Color("rgb(0,0,0)");   
            }
        }

        function travelingColorRing(x, y, time)
        {
            var dist = distanceFromCenter(x,y);
            
            var min = sawtooth(time);
            var max = min + fwgui.bandSize;

            var isLitUp;
            if (max >= 1) {
                max = max - Math.floor(max);
                isLitUp = ( dist >= min || dist < max );
            } else {
                isLitUp = ( dist >= min && dist < max );
            }            
            
            if ( isLitUp ) {
                return new THREE.Color("rgb(255,255,255)");
            } else {
                return new THREE.Color("rgb(0,0,0)");
            }            
        }

        function travelingColorBand(x, y, time)
        {
            return colorSample(map(y,-1,1,time,time+5), fwgui.colorPalette);
        }

        // Gradient going from center outward with new colors everytime
        function ambient(x, y, time)
        {   
            var dist = distanceFromPoint(x,y,interactionCenter.x,interactionCenter.y);

            // White the center if user is interacting
            if (userIsInteracting) {

                var whiteHaloRadius = fwgui.whiteHaloRadius;
                if (dist < whiteHaloRadius) {
                    var white = new THREE.Color("rgb(255,255,255)");
                    var color = colorSample(map(dist,0,1,time+2,time), fwgui.colorPalette);

                    return white.lerp(color,map(dist,0,whiteHaloRadius,0,1));
                }
            }

            return colorSample(map(dist,0,1,time+2,time), fwgui.colorPalette);
        }

        function mandala(x, y, time)
        {
            var TAU = Math.PI * 2;
            var r = Math.sqrt(x*x + y*y);
            var a = Math.atan2(y, x);

            var c = new THREE.Color();
            var lol = (Math.abs(Math.abs(Math.sin(a * 3 + .1*time * TAU)) - r) +.5*time) % 1;
            c.setHSL(lol, 1, .5);
            return c;
        }

        function colorRing(x, y, time)
        {
            return new THREE.Color().setHSL(distanceFromCenter(x,y), 1, .5);
        }

        function plasma(x, y, time)
        {
            // Scale variables to match original shader
            time /= 2;
            x *= 5;
            y *= 100;

            // Source: https://www.shadertoy.com/view/MdXGDH
            var color1, color2, color;

            color1 = (Math.sin(x * Math.sin(time * 3) + y * Math.cos(time * 3) * 0.02 + time * 3) + 1) / 2;

            var center_x = Math.sin(-time * 3);
            var center_y = Math.cos(-time * 3);

            var length = Math.sqrt((x - center_x) * (x - center_x) + (y - center_y) * (y - center_y));
            var color2 = (Math.cos(length * 0.03) + 1) / 2;

            var color = (color1 + color2) / 2;

            return new THREE.Color(
                    (Math.cos(Math.PI * color / 0.5 + time * 3) + 1) / 2,
                    (Math.sin(Math.PI * color / 0.5 + time * 3) + 1) / 2,
                    (Math.sin(+time * 3) + 1) / 2 );
        }

        

    </script>
</body>
</html>