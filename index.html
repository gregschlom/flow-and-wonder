<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="threejs/three.js"></script>
    <script src="threejs/stats.min.js"></script>
    <script src="threejs/OrbitControls.js"></script>    
    <script src="dat.gui.min.js"></script>
    <script src="utils.js"></script>
    <script src="colors.js"></script>
    <script src="HexCoord.js"></script>
    <script src="MousePos.js"></script>
    <script src="fluid2.js"></script>
    <script src="Scene.js"></script>
    <script src="sensor.js"></script>

    <script>

        var FWGUI = function() {            
            this.centerDisplacementSpeed = 0.09;            
            this.fluidSimulationOn = true;
            this.bandSize = 0.25;
            this.speed = 0.5;
            this.colorSpread = 0.3;
            this.whiteHaloRadius = 0.5;
            this.colorFunction = getRandomIntExcluding(1,5,4);  
            this.colorPalette = getRandomInt(0,5);
            this.patternDuration = 20;
            this.transitionDuration = 10;          
        };  

        // Parameters GUI
        var fwgui = new FWGUI();        
        var gui = new dat.GUI();        
        gui.add(fwgui, 'centerDisplacementSpeed',0,1);        
        gui.add(fwgui, 'bandSize',0,1);
        gui.add(fwgui, 'speed',0,1);
        gui.add(fwgui, 'colorSpread',0,1);
        gui.add(fwgui, 'whiteHaloRadius',0,1);
        gui.add(fwgui, 'fluidSimulationOn');        
        gui.add(fwgui, 'colorFunction', { Eiffel: 0, 
                                          TravelingRing: 1, 
                                          Ambient: 2,
                                          TravelingBand: 3,                                         
                                          ColorRing: 4,
                                          Plasma: 5
                                        });

        gui.add(fwgui, 'colorPalette', { Palette1: 0,
                                         Palette2: 1,                              
                                         BW: 2,
                                         Tycho: 3,
                                         Stories: 4,
                                         palette4: 5 });

        gui.add(fwgui, 'patternDuration', 0.5, 600);
        gui.add(fwgui, 'transitionDuration', 0, 600);

        var scene = new Scene();        
        var userIsInteracting = false;
        var interactionCenter = new THREE.Vector2(0,0);                
        var mousePos1 = new MousePos(scene.renderer.domElement, scene.camera, scene, false);
        var mousePos2 = new MousePos(scene.renderer.domElement, scene.camera, scene, true);        

        // Sensors
        var sensor1 = new Sensor(mousePos1);
        var sensor2 = new Sensor(mousePos2);          

        var isTransitioning = false;
        var colorFunction1 = fwgui.colorFunction;
        var colorPalette1 = fwgui.colorPalette;
        var colorFunction2 = fwgui.colorFunction;
        var colorPalette2 = fwgui.colorPalette;
        var transitionT = 0;
        var transitionSteps = 100.0
        var transitionUpdateCallbackID = -1;
        var time = 0;
        var colorGap = 2;
        var bandSize = fwgui.bandSize;
        var speed = fwgui.speed;
        var colorSpread = fwgui.colorSpread;

        //STARTUP CODE
        scene.start();
        setTimeout(function() {
                startTransition();
                }, 1000 * fwgui.patternDuration);


        scene.update = function (frame) {            
            if (sensor2.isActive()) {                                
                speed = map(sensor2.currentPosition().x,-1,1,0,1);
                //colorSpread = map(sensor2.currentPosition().y,-1,1,0,1);                
            } else {
                speed = fwgui.speed;                
                //colorSpread = fwgui.colorSpread;                
            }                
            var divider = map(speed,0,1,60,10);
            time += 1.0/divider;                          

            if (fwgui.fluidSimulationOn) {
                simulate(sensor1);
            }

            // Offset center if user is interacting
            var destination;
            if (sensor1.isActive()) {                
                destination = sensor1.currentPosition()
                userIsInteracting = true;  
            }

            // Going back to center if user is not interaction
            else {
                destination = new THREE.Vector2(0, 0);
                userIsInteracting = false;                
            }

            // var diff = new THREE.Vector2(destination.x - interactionCenter.x, destination.y - interactionCenter.y);
            // interactionCenter.add(diff.multiplyScalar(fwgui.centerDisplacementSpeed));
        };


        // x,y: coords from -1 to 1
        scene.computeColor = function(x, y, frame, state)
        {                     
            // Get the fluid parameters
            // WIDTH and HEIGHT: number of cells in the fluid simulation.
            // Our coords are in [-1, 1] and we want to convert to [0, 100]
            var gx = Math.floor((x + 1) / 2 * WIDTH);
            var gy = Math.floor((y + 1) / 2 * HEIGHT);
            var p = p0(gx, gy);   // pressure
            var u = u0x(gx, gy);  // x-axis velocity
            var v = u0y(gx, gy);  // y-axis velocity

            state.vpos.x += u;
            state.vpos.y += v;

            // bounce off the walls
            if (state.vpos.x < -1) state.vpos.x = -1 - state.vpos.x % 1;
            if (state.vpos.x > 1) state.vpos.x = 1 - state.vpos.x % 1;
            if (state.vpos.y < -1) state.vpos.y = -1 - state.vpos.y % 1;
            if (state.vpos.y > 1) state.vpos.y = 1 - state.vpos.y % 1;

            state.vpos.lerp(new THREE.Vector2(x, y), 1/5);
            
            var c;            
            if (isTransitioning) {
                var c1 = getColor(state.vpos.x, state.vpos.y, time, colorFunction1, colorPalette1);
                var c2 = getColor(state.vpos.x, state.vpos.y, time, colorFunction2, colorPalette2);

                c = c1.clone();
                c.lerp(c2, transitionT);
            } 
            else {
                c = getColor(state.vpos.x, state.vpos.y, time, colorFunction1, colorPalette1);
            }

            if (p < .5) p *= 2;
            c.offsetHSL(0,0, -p);

            return c;
        }        

        function getColor(x, y, time, colorFunction, colorPalette) {
            switch (colorFunction) {
                case 0:
                    return eiffel(x, y, time);                        
                case 1: 
                    return travelingColorRing(x, y, time);                        
                case 2:
                    return ambient(x, y, time, colorPalette);
                case 3:
                    return travelingColorBand(x, y, time, colorPalette);                                    
                case 4:
                    return colorRing(x, y, time);                        
                case 5:
                    return plasma(x, y, time);                        
                
                default:
                    return ambient(x, y, time, colorPalette);            
            }            
        }

        function startTransition() {
            isTransitioning = true
            transitionT = 0            

            //pick random destination palette
            colorPalette2 = getRandomInt(0,5);

            //if the previous function was colorful
            if (colorFunction1 >= 2) {

                //pick random destination color function that is black and white                
                colorFunction2 = getRandomIntExcluding(0,3,colorFunction1);

                //if we got ambient or traveling band, pick b&w palette
                if (colorFunction2 == 2 || colorFunction2 == 3) {
                    colorPalette2 = 2;

                    if (colorFunction1 != 2 && colorFunction1 != 3) {
                        colorSpread = Math.random();
                    }
                }

                //if it's the b$w ring, pick a random band size between 0.15 and 0.85
                if (colorFunction2 == 1) {
                    bandSize = map(Math.random(),0,1,0.15,0.85)
                }         
            }

            //if the previous function was bw
            else {

                //pick random destination color function that is colorful
                colorFunction2 = getRandomInt(2,5);

                //if we got ambient or traveling band
                if (colorFunction2 == 2 || colorFunction2 == 3) {
                    colorSpread = Math.random();
                }
            }
                           
            console.log(colorFunction2);


            //callback to update transition
            if (transitionUpdateCallbackID == -1) {
                transitionUpdateCallbackID = setInterval(function() {
                                                updateTransition();
                                             }, (1000 * fwgui.transitionDuration)/transitionSteps);
            }

            //callback for end transition
            setTimeout(function() {
                endTransition();
                }, 1000 * fwgui.transitionDuration);
        }

        function endTransition() {
            isTransitioning = false

            //swap palette and function
            colorPalette1 = colorPalette2
            colorFunction1 = colorFunction2

            //if it's eiffel, set a short pattern duration
            var patternDuration = fwgui.patternDuration;
            if (colorFunction1 == 0) {
                patternDuration = 1;
            }

            //if it's black and white, shorter than color
            if (colorFunction1 == 1) {
                patternDuration = 10;
            }

            if ((colorFunction1 == 2 || colorFunction1 == 3) && colorPalette1 == 2) {
                patternDuration = 20;
            }

            if (colorFunction1 >= 2) {
                patternDuration = 60;
            }

            //if it's color ring, set short pattern duration
            if (colorFunction1 == 4) {
                patternDuration = 10;
            }            

            //callback for start transition
            setTimeout(function() {
                startTransition();
                }, 1000 * patternDuration);

            //cancel callback for update
            clearInterval(transitionUpdateCallbackID);
            transitionUpdateCallbackID = -1;
        }

        function updateTransition() {
            transitionT += 1 / transitionSteps;
            transitionT.clamp(0,1);
        }

        function eiffel(x, y, time)
        {   
            if (getRandomInt(1,2) % 2 == 0) {
                return new THREE.Color("rgb(255,255,255)");
            }

            else {
                return new THREE.Color("rgb(0,0,0)");   
            }
        }

        function travelingColorRing(x, y, time)
        {
            var dist = distanceFromCenter(x,y);
            
            var min = sawtooth(time);
            var max = min + bandSize;

            var isLitUp;
            if (max >= 1) {
                max = max - Math.floor(max);
                isLitUp = ( dist >= min || dist < max );
            } else {
                isLitUp = ( dist >= min && dist < max );
            }            
            
            if ( isLitUp ) {
                return new THREE.Color("rgb(255,255,255)");
            } else {
                return new THREE.Color("rgb(0,0,0)");
            }            
        }

        function travelingColorBand(x, y, time, colorPalette)
        {
            return colorSample(map(y,-1,1,time,time+map(colorSpread,0,1,5,30)), colorPalette);
        }

        // Gradient going from center outward with new colors everytime
        function ambient(x, y, time, colorPalette)
        {   
            var dist = distanceFromPoint(x,y,interactionCenter.x,interactionCenter.y);
            var color = colorSample(map(dist,0,1,time+map(colorSpread,0,1,2,15),time), colorPalette);

            // White the center if user is interacting
            if (userIsInteracting) {

                var whiteHaloRadius = fwgui.whiteHaloRadius;
                if (dist < whiteHaloRadius) {
                    var white = new THREE.Color("rgb(255,255,255)");                    
                    return white.lerp(color,map(dist,0,whiteHaloRadius,0,1));
                }
            }

            return color;
        }

        function mandala(x, y, time)
        {
            var TAU = Math.PI * 2;
            var r = Math.sqrt(x*x + y*y);
            var a = Math.atan2(y, x);

            var c = new THREE.Color();
            var lol = (Math.abs(Math.abs(Math.sin(a * 3 + .1*time * TAU)) - r) +.5*time) % 1;
            c.setHSL(lol, 1, .5);
            return c;
        }

        function colorRing(x, y, time)
        {
            return new THREE.Color().setHSL(distanceFromCenter(x,y), 1, .5);
        }

        function plasma(x, y, time)
        {
            // Scale variables to match original shader
            time /= 2;
            x *= 5;
            y *= 100;

            // Source: https://www.shadertoy.com/view/MdXGDH
            var color1, color2, color;

            color1 = (Math.sin(x * Math.sin(time * 3) + y * Math.cos(time * 3) * 0.02 + time * 3) + 1) / 2;

            var center_x = Math.sin(-time * 3);
            var center_y = Math.cos(-time * 3);

            var length = Math.sqrt((x - center_x) * (x - center_x) + (y - center_y) * (y - center_y));
            var color2 = (Math.cos(length * 0.03) + 1) / 2;

            var color = (color1 + color2) / 2;

            return new THREE.Color(
                    (Math.cos(Math.PI * color / 0.5 + time * 3) + 1) / 2,
                    (Math.sin(Math.PI * color / 0.5 + time * 3) + 1) / 2,
                    (Math.sin(+time * 3) + 1) / 2 );
        }

        

    </script>
</body>
</html>