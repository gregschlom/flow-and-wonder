<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="threejs/three.js"></script>
    <script src="threejs/stats.min.js"></script>
    <script src="threejs/OrbitControls.js"></script>
    <script src="utils.js"></script>
    <script src="HexCoord.js"></script>
    <script src="MousePos.js"></script>
    <script src="Fluid.js"></script>
    <script src="Scene.js"></script>

    <script>


        var scene = new Scene();
        var mousePos = new MousePos(scene.renderer.domElement, scene.camera);
        var fluid = new NavierStokes({ });
        fluid.init();


        scene.render = function (frame, time, geometry) {


            for (var i = 0; i < geometry.vertices.length; i++) {
                var pos = geometry.vertices[i];
                var hex = geometry.hex[i];

                var r = hex.polarRadius() / geometry.radius;
                var a = Math.TAU * hex.polarIndex() / (6 * hex.polarRadius());
                geometry.colors[i] = computeColorPolar(r, a, frame);
                //geometry.colors[i] = computeColor(pos.x, pos.z, frame);
            }


            var newU = new Array();
            var newV = new Array();

            if (mousePos.last && mousePos.cur) {

                var px = Math.floor((mousePos.cur.x + 1) / 2 * fluid.settings.resolution) + 1;
                var py = Math.floor((mousePos.cur.y + 1) / 2 * fluid.settings.resolution) + 1;

                if (px < 1 || px >= fluid.settings.resolution || py < 1 || py >= fluid.settings.resolution) return;

                var index = fluid.IX[px][py];


                newU[index] = (mousePos.cur.x - mousePos.last.x) * 100;
                newV[index] = (mousePos.cur.y - mousePos.last.y) * 100;
            }

            fluid.update(newU, newV);

            for (var i = 0; i < geometry.vertices.length; i++) {

                // Update the position based on the fluid
                var pos = geometry.vertices[i];
                var px = Math.floor((pos.x + 1) / 2 * fluid.settings.resolution) + 1;
                var py = Math.floor((pos.z + 1) / 2 * fluid.settings.resolution) + 1;

                var index = fluid.IX[px][py];
                pos.x += fluid.U[index];
                pos.z += fluid.V[index];

                // Bounce off the walls
                if (pos.x < -1) pos.x -= 2 * pos.x % -1;
                if (pos.x > 1) pos.x -= 2 * pos.x % 1;
                if (pos.z < -1) pos.z -= 2 * pos.z % -1;
                if (pos.z > 1) pos.z -= 2 * pos.z % 1;

                pos.x = pos.x.clamp(-1, 1);
                pos.z = pos.z.clamp(-1, 1);

                // Return to original position
                var minSpeed = .001;
                if (fluid.U[index] < minSpeed && fluid.V[index] < minSpeed) {
                    var hex = geometry.hex[i];
                    var origPos = hex.position();
                    origPos.normalize().multiplyScalar(hex.polarRadius() / geometry.radius);
                    origPos = new THREE.Vector3(origPos.x, 0, origPos.y);
                    pos.lerp(origPos, 1 / 100);
                }
            }

            geometry.verticesNeedUpdate = true;
            geometry.colorsNeedUpdate = true;
        };

        // return the color at a given x,y coordinate
        // x and y are normalized in [-1, 1].
        function computeColor(x, y, frame) {}

        // r: radius normalized in [0, 1]
        // a: angle in radians [0, 2π]
        function computeColorPolar(r, a, frame)
        {
            // trippy mandala
            var time = frame / 60;
            var c = new THREE.Color();
            var lol = (Math.abs(Math.abs(Math.sin(a * 3 + .2*time * Math.TAU)) - r) + time) % 1;
            c.setHSL(lol, 1, .5);
            return c;
        }

        scene.start();

    </script>
</body>
</html>