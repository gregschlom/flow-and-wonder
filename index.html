<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="threejs/three.js"></script>
    <script src="threejs/stats.min.js"></script>
    <script src="threejs/OrbitControls.js"></script>    
    <script src="dat.gui.min.js"></script>
    <script src="utils.js"></script>
    <script src="colors.js"></script>
    <script src="HexCoord.js"></script>
    <script src="MousePos.js"></script>
    <script src="fluid2.js"></script>
    <script src="Scene.js"></script>
    <script src="sensor.js"></script>

    <script>

        var FWGUI = function() {            
            this.centerDisplacementSpeed = 0.09;            
            this.fluidSimulationOn = true;
            this.bandSize = 0.25;
            this.whiteHaloRadius = 0.5;
            this.colorFunction = 2;  
            this.colorPalette = 3;
            this.patternDuration = 20;
            this.transitionDuration = 20;          
        };  

        // Parameters GUI
        var fwgui = new FWGUI();        
        var gui = new dat.GUI();        
        gui.add(fwgui, 'centerDisplacementSpeed',0,1);        
        gui.add(fwgui, 'bandSize',0,1);
        gui.add(fwgui, 'whiteHaloRadius',0,1);
        gui.add(fwgui, 'fluidSimulationOn');        
        gui.add(fwgui, 'colorFunction', { Eiffel: 0, 
                                          TravelingRing: 1, 
                                          Ambient: 2,                                          
                                          ColorRing: 3,
                                          Plasma: 4,
                                          TravelingBand: 5 });

        gui.add(fwgui, 'colorPalette', { Palette1: 0,
                                         Palette2: 1,                              
                                         BW: 2,
                                         Tycho: 3,
                                         Stories: 4 });
        gui.add(fwgui, 'patternDuration', 0.5, 600);
        gui.add(fwgui, 'transitionDuration', 0, 600);

        var scene = new Scene();
        var mousePos = new MousePos(scene.renderer.domElement, scene.camera, scene);        
        var userIsInteracting = false;
        var interactionCenter = new THREE.Vector2(0,0);                

        // Sensors
        var sensor1 = new Sensor(mousePos);
        var sensor2 = new Sensor(mousePos);          

        var isTransitioning = false;
        var colorFunction1 = fwgui.colorFunction;
        var colorPalette1 = fwgui.colorPalette;
        var colorFunction2 = fwgui.colorFunction;
        var colorPalette2 = fwgui.colorPalette;
        var transitionT = 0;
        var transitionSteps = 100.0
        var transitionUpdateCallbackID = -1;

        //STARTUP CODE
        scene.start();
        setTimeout(function() {
                startTransition();
                }, 1000 * fwgui.patternDuration);


        scene.update = function (frame) {
            if (fwgui.fluidSimulationOn) {
                simulate(sensor1);
            }

            // Offset center if user is interacting
            var destination;
            if (sensor1.isActive()) {                
                destination = sensor1.currentPosition()
                userIsInteracting = true;  
            }
            // Going back to center if user is not interaction
            else {
                destination = new THREE.Vector2(0, 0);
                userIsInteracting = false;                
            }

            var diff = new THREE.Vector2(destination.x - interactionCenter.x, destination.y - interactionCenter.y);
            interactionCenter.add(diff.multiplyScalar(fwgui.centerDisplacementSpeed));
        };


        // x,y: coords from -1 to 1
        scene.computeColor = function(x, y, frame, state)
        {
            var time = frame / 60;            

            // Get the fluid parameters
            // WIDTH and HEIGHT: number of cells in the fluid simulation.
            // Our coords are in [-1, 1] and we want to convert to [0, 100]
            var gx = Math.floor((x + 1) / 2 * WIDTH);
            var gy = Math.floor((y + 1) / 2 * HEIGHT);
            var p = p0(gx, gy);   // pressure
            var u = u0x(gx, gy);  // x-axis velocity
            var v = u0y(gx, gy);  // y-axis velocity

            state.vpos.x += u;
            state.vpos.y += v;

            // bounce off the walls
            if (state.vpos.x < -1) state.vpos.x = -1 - state.vpos.x % 1;
            if (state.vpos.x > 1) state.vpos.x = 1 - state.vpos.x % 1;
            if (state.vpos.y < -1) state.vpos.y = -1 - state.vpos.y % 1;
            if (state.vpos.y > 1) state.vpos.y = 1 - state.vpos.y % 1;

            state.vpos.lerp(new THREE.Vector2(x, y), 1/5);
            
            var c;            
            if (isTransitioning) {
                var c1 = getColor(state.vpos.x, state.vpos.y, time, colorFunction1, colorPalette1);
                var c2 = getColor(state.vpos.x, state.vpos.y, time, colorFunction2, colorPalette2);

                c = c1.clone();
                c.lerp(c2, transitionT);
            } 
            else {
                c = getColor(state.vpos.x, state.vpos.y, time, colorFunction1, colorPalette1);
            }

            if (p < .5) p *= 2;
            c.offsetHSL(0,0, -p);

            return c;
        }        

        function getColor(x, y, time, colorFunction, colorPalette) {
            switch (colorFunction) {
                case 0:
                    return eiffel(x, y, time);                        
                case 1: 
                    return travelingColorRing(x, y, time);                        
                case 2:
                    return ambient(x, y, time, colorPalette);            
                case 3:
                    return colorRing(x, y, time);                        
                case 4:
                    return plasma(x, y, time);                        
                case 5:
                    return travelingColorBand(x, y, time, colorPalette);                        
                default:
                    return ambient(x, y, time, colorPalette);            
            }            
        }

        function startTransition() {
            isTransitioning = true
            transitionT = 0

            //pick random destination palette
            colorPalette2 = getRandomInt(0,4)

            //pick random destination color function
            colorFunction2 = getRandomInt(0,5)

            //callback to update transition
            if (transitionUpdateCallbackID == -1) {
                transitionUpdateCallbackID = setInterval(function() {
                                                updateTransition();
                                             }, (1000 * fwgui.transitionDuration)/transitionSteps);
            }

            //callback for end transition
            setTimeout(function() {
                endTransition();
                }, 1000 * fwgui.transitionDuration);
        }

        function endTransition() {
            isTransitioning = false

            //swap palette and function
            colorPalette1 = colorPalette2
            colorFunction1 = colorFunction2

            //callback for start transition
            setTimeout(function() {
                startTransition();
                }, 1000 * fwgui.patternDuration);

            //cancel callback for update
            clearInterval(transitionUpdateCallbackID);
            transitionUpdateCallbackID = -1;
        }

        function updateTransition() {
            transitionT += 1 / transitionSteps;
            transitionT.clamp(0,1);
        }

        function eiffel(x, y, time)
        {   
            if (getRandomInt(1,2) % 2 == 0) {
                return new THREE.Color("rgb(255,255,255)");
            }

            else {
                return new THREE.Color("rgb(0,0,0)");   
            }
        }

        function travelingColorRing(x, y, time)
        {
            var dist = distanceFromCenter(x,y);
            
            var min = sawtooth(time);
            var max = min + fwgui.bandSize;

            var isLitUp;
            if (max >= 1) {
                max = max - Math.floor(max);
                isLitUp = ( dist >= min || dist < max );
            } else {
                isLitUp = ( dist >= min && dist < max );
            }            
            
            if ( isLitUp ) {
                return new THREE.Color("rgb(255,255,255)");
            } else {
                return new THREE.Color("rgb(0,0,0)");
            }            
        }

        function travelingColorBand(x, y, time, colorPalette)
        {
            return colorSample(map(y,-1,1,time,time+5), colorPalette);
        }

        // Gradient going from center outward with new colors everytime
        function ambient(x, y, time, colorPalette)
        {   
            var dist = distanceFromPoint(x,y,interactionCenter.x,interactionCenter.y);
            var color = colorSample(map(dist,0,1,time+2,time), colorPalette);

            // White the center if user is interacting
            if (userIsInteracting) {

                var whiteHaloRadius = fwgui.whiteHaloRadius;
                if (dist < whiteHaloRadius) {
                    var white = new THREE.Color("rgb(255,255,255)");                    
                    return white.lerp(color,map(dist,0,whiteHaloRadius,0,1));
                }
            }

            return color;
        }

        function mandala(x, y, time)
        {
            var TAU = Math.PI * 2;
            var r = Math.sqrt(x*x + y*y);
            var a = Math.atan2(y, x);

            var c = new THREE.Color();
            var lol = (Math.abs(Math.abs(Math.sin(a * 3 + .1*time * TAU)) - r) +.5*time) % 1;
            c.setHSL(lol, 1, .5);
            return c;
        }

        function colorRing(x, y, time)
        {
            return new THREE.Color().setHSL(distanceFromCenter(x,y), 1, .5);
        }

        function plasma(x, y, time)
        {
            // Scale variables to match original shader
            time /= 2;
            x *= 5;
            y *= 100;

            // Source: https://www.shadertoy.com/view/MdXGDH
            var color1, color2, color;

            color1 = (Math.sin(x * Math.sin(time * 3) + y * Math.cos(time * 3) * 0.02 + time * 3) + 1) / 2;

            var center_x = Math.sin(-time * 3);
            var center_y = Math.cos(-time * 3);

            var length = Math.sqrt((x - center_x) * (x - center_x) + (y - center_y) * (y - center_y));
            var color2 = (Math.cos(length * 0.03) + 1) / 2;

            var color = (color1 + color2) / 2;

            return new THREE.Color(
                    (Math.cos(Math.PI * color / 0.5 + time * 3) + 1) / 2,
                    (Math.sin(Math.PI * color / 0.5 + time * 3) + 1) / 2,
                    (Math.sin(+time * 3) + 1) / 2 );
        }

        

    </script>
</body>
</html>